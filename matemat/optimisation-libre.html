<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<!-- 2025-12-30 mar 16:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Eclats de vers : Matemat : Optimisation libre</title>
<meta name="author" content="chimay" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../style/defaut.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Eclats de vers : Matemat : Optimisation libre</h1>
<p>
<a href="index.html">Index mathématique</a>
</p>

<p>
<a href="../index.html">Retour à l’accueil</a>
</p>

<div id="table-of-contents" role="doc-toc">
<h2>Table des matières</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org7d3e745">1. Minimum</a></li>
<li><a href="#org05162e9">2. Maximum</a></li>
<li><a href="#org4cd4338">3. Equivalence</a></li>
<li><a href="#org9897091">4. Dérivées ordinaires</a></li>
<li><a href="#orge0a1ba0">5. Point de selle</a></li>
<li><a href="#orgb255606">6. Convexité</a></li>
<li><a href="#org53fbc2d">7. Convexité stricte</a></li>
<li><a href="#org6d3acc7">8. Concavité</a></li>
<li><a href="#orgdc0b8eb">9. Concavité stricte</a></li>
<li><a href="#org6ab4468">10. Equation du second degré</a></li>
<li><a href="#org8e4442a">11. Moindres-carrés</a></li>
</ul>
</div>
</div>

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    packages: {'[+]': ['base','ams','braket']},
    macros: {
      parentheses: ["\\left(#1\\right)", 1],
      crochets: ["\\left[#1\\right]", 1],
      accolades: ["\\left\\{#1\\right\\}", 1],
      ensemble: ["\\left\\{#1\\right\\}", 1],
      cardinal: ["\\mathop{\\mathrm{card}\\ }\\limits",0],
      identite: "\\mathrm{Id}",
      indicatrice: "\\boldsymbol{\\delta}",
      dirac: "\\delta",
      moinsun: "-1",
      inverse: "\\ddagger",
      pinverse: "\\dagger",
      topologie: "\\mathfrak{T}",
      ferme: "\\mathfrak{F}",
      img: "\\mathbf{i}",
      binome: ["\\left\\{ \\begin{array}{c} #1 \\\\ #2 \\\\ \\end{array} \\right\\}", 2],
      canonique: "\\mathfrak{c}",
      tenseuridentite: "\\boldsymbol{\\mathcal{I}}",
      permutation: "\\boldsymbol{\\epsilon}",
      matriceZero: "\\mathfrak{0}",
      matriceUn: "\\mathfrak{1}",
      christoffel: ["\\left\\{ \\begin{array}{c} #1 \\\\ #2 \\\\ \\end{array} \\right\\}", 2],
      lagrangien: "\\mathfrak{L}",
      sousens: "\\mathfrak{P}",
      partition: "\\mathrm{Partition}",
      tribu: "\\mathrm{Tribu}",
      topologies: "\\mathrm{Topo}",
      setB: "\\mathbb{B}",
      setN: "\\mathbb{N}",
      setZ: "\\mathbb{Z}",
      setQ: "\\mathbb{Q}",
      setR: "\\mathbb{R}",
      setC: "\\mathbb{C}",
      corps: "\\mathbb{K}",
      boule: "\\mathfrak{B}",
      intervalleouvert: ["\\left] #1 , #2 \\right[", 2],
      intervallesemiouvertgauche: ["\\left] #1 , #2 \\right]", 2],
      intervallesemiouvertdroite: ["\\left[ #1 , #2 \\right[", 2],
      fonction: "\\mathbb{F}",
      bijection: "\\mathrm{Bij}",
      polynome: "\\mathrm{Poly}",
      lineaire: "\\mathrm{Lin}",
      continue: "\\mathrm{Cont}",
      homeomorphisme: "\\mathrm{Hom}",
      etagee: "\\mathrm{Etagee}",
      lebesgue: "\\mathrm{Leb}",
      lipschitz: "\\mathrm{Lip}",
      suitek: "\\mathrm{Suite}",
      matrice: "\\mathbb{M}",
      krylov: "\\mathrm{Krylov}",
      tenseur: "\\mathbb{T}",
      essentiel: "\\mathfrak{E}",
      relation: "\\mathrm{Rel}",
      strictinferieur: "<",
      strictsuperieur: ">",
      ensinferieur: "\\eqslantless",
      enssuperieur: "\\eqslantgtr",
      esssuperieur: "\\gtrsim",
      essinferieur: "\\lesssim",
      essegal: "\\eqsim",
      union: "\\cup",
      intersection: "\\cap",
      opera: "\\divideontimes",
      autreaddition: "\\boxplus",
      autremultiplication: "\\circledast",
      commutateur: ["\\left[ #1 , #2 \\right]", 2],
      convolution: "\\circledcirc",
      correlation: "\\natural",
      diventiere: "\\div",
      modulo: "\\bmod",
      pgcd: ["\\mathop{\\mathrm{pgcd}\\ }\\limits",0],
      ppcm: ["\\mathop{\\mathrm{ppcm}\\ }\\limits",0],
      produitscalaire: ["\\left\\langle #1 \\vert #2 \\right\\rangle", 2],
      scalaire: ["\\left\\langle #1 \\| #2 \\right\\rangle", 2],
      braket: ["\\left\\langle #1 \\vert #2 \\vert #3 \\right\\rangle", 3],
      orthogonal: "\\bot",
      forme: ["\\left\\langle #1 , #2 \\right\\rangle", 2],
      biforme: ["\\left\\langle #1 , #2 , #3 \\right\\rangle", 3],
      contraction: ["\\left\\langle #1 \\odot #3 \\right\\rangle_{#2}", 3],
      dblecont: ["\\left\\langle #1 \\vert #3 \\vert #5 \\right\\rangle_{#2,#4}", 5],
      major: ["\\mathop{\\mathrm{major}\\ }\\limits",0],
      minor: ["\\mathop{\\mathrm{minor}\\ }\\limits",0],
      maxim: ["\\mathop{\\mathrm{maxim}\\ }\\limits",0],
      minim: ["\\mathop{\\mathrm{minim}\\ }\\limits",0],
      argument: ["\\mathop{\\mathrm{arg}\\ }\\limits",0],
      argmin: ["\\mathop{\\mathrm{arg\\,min}\\ }\\limits",0],
      argmax: ["\\mathop{\\mathrm{arg\\,max}\\ }\\limits",0],
      supessentiel: ["\\mathop{\\mathrm{ess\\,sup}\\ }\\limits",0],
      infessentiel: ["\\mathop{\\mathrm{ess\\,inf}\\ }\\limits",0],
      dual: "\\star",
      vardual: "\\circledast",
      distance: "\\mathfrak{dist}",
      norme: ["\\left\\lVert #1 \\right\\rVert", 1],
      normetrois: ["\\left|\\left\\| #1 \\right\\|\\right|", 1],
      adh: ["\\mathop{\\mathrm{adh}\\ }\\limits",0],
      interieur: ["\\mathop{\\mathrm{int}\\ }\\limits",0],
      frontiere: "\\partial",
      image: ["\\mathop{\\mathrm{im}\\ }\\limits",0],
      domaine: ["\\mathop{\\mathrm{dom}\\ }\\limits",0],
      noyau: ["\\mathop{\\mathrm{ker}\\ }\\limits",0],
      support: ["\\mathop{\\mathrm{supp}\\ }\\limits",0],
      signe: ["\\mathop{\\mathrm{sign}\\ }\\limits",0],
      abs: ["\\left\\lvert #1 \\right\\rvert", 1],
      unsur: ["\\frac{1}{#1}", 1],
      arrondisup: ["\\lceil #1 \\rceil", 1],
      arrondiinf: ["\\lfloor #1 \\rfloor", 1],
      conjugue: "\\mathrm{conj\\ }",
      conjaccent: ["\\overline{#1}", 1],
      division: "division",
      difference: "\\boldsymbol{\\Delta}",
      differentielle: ["\\mathfrak{D}^{#1}_{#2}", 2],
      OD: ["\\frac{d #1}{d #2}", 2],
      OOD: ["\\frac{d^2 #1}{d #2^2}", 2],
      NOD: ["\\frac{d^{#3} #1}{d #2^{#3}}", 3],
      deriveepartielle: ["\\frac{\\partial #1}{\\partial #2}", 2],
      PD: ["\\frac{\\partial #1}{\\partial #2}", 2],
      dblederiveepartielle: ["\\frac{\\partial^2 #1}{\\partial #2 \\partial #2}", 2],
      dfdxdy: ["\\frac{\\partial^2 #1}{\\partial #2 \\partial #3}", 3],
      dfdxdx: ["\\frac{\\partial^2 #1}{\\partial #2^2}", 2],
      gradient: "\\mathbf{\\nabla}",
      combilin: ["\\mathrm{span}\\{ #1 \\}", 1],
      trace: "tr",
      proba: "\\mathbb{P}",
      probaof: ["\\mathbb{P}\\left[#1\\right]", 1],
      esperof: ["\\mathbb{E}\\left[#1\\right]", 1],
      cov: ["\\mathrm{cov} ( #1 , #2 )", 2],
      var: ["\\mathrm{var} ( #1 )", 1],
      rand: "\\mathrm{rand}",
      variation: ["\\left\\langle #1 \\right\\rangle", 1],
      composante: ["\\mathop{\\mathrm{comp}\\ }\\limits",0],
      bloc: ["\\mathop{\\mathrm{bloc}\\ }\\limits",0],
      ligne: ["\\mathop{\\mathrm{ligne}\\ }\\limits",0],
      colonne: ["\\mathop{\\mathrm{colonne}\\ }\\limits",0],
      diagonale: ["\\mathop{\\mathrm{diag}\\ }\\limits",0],
      matelementaire: "\\mathrm{Elem}",
      matpermutation: ["\\mathop{\\mathrm{permut}\\ }\\limits",0],
      matunitaire: "\\mathrm{Unitaire}",
      gaussjordan: "\\mathrm{GaussJordan}",
      householder: "\\mathrm{Householder}",
      rang: "rang",
      schur: "\\mathrm{Schur}",
      singuliere: "\\mathrm{DVS}",
      convexe: "\\mathrm{Convexe}",
      petito: ["o(#1)", 1],
      grando: ["O(#1)", 1]
    }
  }
};
</script>

<!-- simple online version -->
<!-- <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> -->

<!-- script embedded in tree -->
<!-- <script src="../include/mathjax/tex-mml-chtml.js"></script> -->

<!-- hybrid online/offline -->
<!-- does not work -->

<p>
\(
\renewenvironment{Eqts}
{ \begin{equation*} \begin{gathered} }
{ \end{gathered} \end{equation*} }
\renewenvironment{Matrix}
{\left[ \begin{array}}
{\end{array} \right]}
\)
</p>

<p>
\label{chap:optimisationlibre}
</p>
<div id="outline-container-org7d3e745" class="outline-2">
<h2 id="org7d3e745"><span class="section-number-2">1.</span> Minimum</h2>
<div class="outline-text-2" id="text-1">
<p>
Soit \(\varphi \in \continue^2(\setR^n,\setR)\). Supposons que \(a \in \setR^n\) annule la Jacobienne (on parlera ici plutôt de gradient) :
</p>

<p>
\[\partial \varphi(a) = 0\]
</p>

<p>
Supposons également que la Hessienne en \(a\) soit définie positive, c'est-à-dire que :
</p>

<p>
\[\Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta \ge 0\]
</p>

<p>
pour tout \(\Delta \in \setR^n\) qui vérifie \(\Delta \ne 0\). Si ces conditions sont remplies, nous nous proposons de montrer que \(\varphi\) atteint un minimum local en \(a\). On peut donc trouver \(\delta \strictsuperieur 0\) tel que :
</p>

<p>
\[\varphi(a) \le \varphi(a + \Delta)\]
</p>

<p>
pour tout \(\Delta \in \setR^n\) vérifiant \(\norme{\Delta} \le \delta\). A l'inverse, si \(\varphi\) atteint un minimum local en \(a\), les conditions sur le gradient et la Hessienne seront remplies.
</p>

<ul class="org-ul">
<li>Supposons que les conditions sur le gradient et la hessienne soit remplies. Le développement d'ordre deux :</li>
</ul>

<p>
\[\varphi(a + \Delta) = \varphi(a) + \partial \varphi(a) \cdot \Delta + \unsur{2} \Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta + E(\Delta)\]
</p>

<p>
où \(E \sim \petito{\Delta^2}\) devient alors simplement :
</p>

<p>
\[\varphi(a + \Delta) = \varphi(a) + \unsur{2} \Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta + E(\Delta)\]
</p>

<p>
Choisissons \(h \in \setR^n\). Pour un \(\lambda \in \setR\) quelconque, posons \(\Delta = \lambda \cdot h\). On a alors :
</p>

<p>
\[\varphi(a + \Delta) = \varphi(a) + \frac{\lambda^2}{2} \cdot h^\dual \cdot \partial^2 \varphi(a) \cdot h + E(\lambda \cdot h)\]
</p>

<p>
Mais comme la Hessienne est définie positive et que \(E\) converge plus vite que \(\norme{\Delta}^2 = \lambda^2 \cdot \norme{h}^2\) vers \(0\), il suffit de choisir \(\lambda \strictsuperieur 0\) assez petit pour avoir :
</p>

<p>
\[\abs{E(\lambda \cdot h)} \le \frac{\lambda^2}{2} \cdot h^\dual \cdot \partial^2 \varphi(a) \cdot h\]
</p>

<p>
on a alors :
</p>

<p>
\[\unsur{2} \Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta + E(\Delta) \ge \unsur{2} \Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta - \abs{E(\Delta)} \ge 0\]
</p>

<p>
et :
</p>

<p>
\[\varphi(a + \Delta) = \varphi(a) + \unsur{2} \cdot \Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta + E(\Delta) \ge \varphi(a)\]
</p>

<p>
Nous avons donc bien un minimum local de \(\varphi\) en \(a\).
</p>

<ul class="org-ul">
<li>Inversément, si \(\varphi\) atteint un minimum local en \(a\), nous avons vu que la différentielle s'annulait. La jacobienne s'annule donc aussi et le développement d'ordre deux devient :</li>
</ul>

<p>
\[\varphi(a + \Delta) = \varphi(a) + \unsur{2} \Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta + E(\Delta) \ge \varphi(a)\]
</p>

<p>
La condition de minimum local nous dit donc que :
</p>

<p>
\[\Delta^\dual \cdot \partial^2 f(a) \cdot \Delta + E(\Delta) \ge 0\]
</p>

<p>
Choisissons à nouveau \(h \in \setR^n\) et posons \(\Delta = \lambda \cdot h\) pour un  \(\lambda \in \setR\) quelconque. On a alors :
</p>

<p>
\[\frac{\lambda^2}{2} \cdot h^\dual \cdot \partial^2 f(a) \cdot h + E(\lambda \cdot h) \ge 0\]
</p>

<p>
Divisant par \(\lambda^2\), on obtient :
</p>

<p>
\[\unsur{2} \cdot h^\dual \cdot \partial^2 f(a) \cdot h + \frac{E(\lambda \cdot h)}{\lambda^2 \cdot \norme{h}^2} \cdot \norme{h}^2 \ge 0\]
</p>

<p>
Si on fait tendre \(\lambda \strictsuperieur 0\) vers \(0\), on arrive à la relation :
</p>

<p>
\[\unsur{2} \cdot h^\dual \cdot \partial^2 f(a) \cdot h \ge 0\]
</p>

<p>
Comme ce résultat est valable quel que soit \(h \in \setR^n\), on en conclut que la Hessienne est définie positive.
</p>
</div>
</div>
<div id="outline-container-org05162e9" class="outline-2">
<h2 id="org05162e9"><span class="section-number-2">2.</span> Maximum</h2>
<div class="outline-text-2" id="text-2">
<p>
Un raisonnement analogue nous montre que :
</p>

<p>
Soit \(\varphi \in \continue^2(\setR^n,\setR)\). Supposons que \(a \in \setR^n\) annule la Jacobienne (on parlera ici plutôt de gradient) :
</p>

<p>
\[\partial \varphi(a) = 0\]
</p>

<p>
Supposons également que la Hessienne en \(a\) soit définie négative, c'est-à-dire que :
</p>

<p>
\[\Delta^\dual \cdot \partial^2 \varphi(a) \cdot \Delta \le 0\]
</p>

<p>
pour tout \(\Delta \in \setR^n\) qui vérifie \(\Delta \ne 0\). Si ces conditions sont remplies, \(\varphi\) atteint un maximum local en \(a\). On peut donc trouver \(\delta \strictsuperieur 0\) tel que :
</p>

<p>
\[\varphi(a) \ge \varphi(a + \Delta)\]
</p>

<p>
pour tout \(\Delta \in \setR^n\) vérifiant \(\norme{\Delta} \le \delta\). A l'inverse, si \(\varphi\) atteint un maximum local en \(a\), les conditions sur le gradient et la Hessienne seront remplies.
</p>
</div>
</div>
<div id="outline-container-org4cd4338" class="outline-2">
<h2 id="org4cd4338"><span class="section-number-2">3.</span> Equivalence</h2>
<div class="outline-text-2" id="text-3">
<p>
En pratique, on peut toujours se ramener à un problème de minimisation.
En effet, maximiser une fonction revient à minimiser son opposé :
</p>

<p>
\[\arg\max_{x \in A} \varphi(x) = \arg\min_{x \in A} (-\varphi(x))\]
</p>

<p>
Nous nous restreindrons donc dans la suite aux problèmes de minimisation.
</p>
</div>
</div>
<div id="outline-container-org9897091" class="outline-2">
<h2 id="org9897091"><span class="section-number-2">4.</span> Dérivées ordinaires</h2>
<div class="outline-text-2" id="text-4">
<p>
Pour des fonctions \(f: \setR \mapsto \setR\), les conditions
se simplifient en :
</p>

<div class="org-center">
<p>
\(
\OD{f}{t}(a) = 0 \)
</p>

<p>
\(
\OOD{f}{t}(a) \ge 0
\)
</p>
</div>

<p>
pour un minimum et en :
</p>

<div class="org-center">
<p>
\(
\OD{f}{t}(a) = 0 \)
</p>

<p>
\(
\OOD{f}{t}(a) \le 0
\)
</p>
</div>

<p>
pour un maximum.
</p>
</div>
</div>
<div id="outline-container-orge0a1ba0" class="outline-2">
<h2 id="orge0a1ba0"><span class="section-number-2">5.</span> Point de selle</h2>
<div class="outline-text-2" id="text-5">
<p>
Soit une fonction \(\lagrangien : \setR^n \times \setR^m \mapsto \setR\). Un point de selle \((\gamma,\lambda) \in \setR^n \times \setR^m\) est un couple d'élément qui minimise \(\lagrangien(x,y)\) par rapport à \(x\) et qui la maximise par rapport à \(y\). On aura alors :
</p>

<p>
\[\lagrangien(\gamma,y) \le \lagrangien(\gamma,\lambda) \le \lagrangien(x,\lambda)\]
</p>
</div>
</div>
<div id="outline-container-orgb255606" class="outline-2">
<h2 id="orgb255606"><span class="section-number-2">6.</span> Convexité</h2>
<div class="outline-text-2" id="text-6">
<p>
Soit l'ensemble :
</p>

<p>
\[L = \{ (s,t) \in \setR^2 : (s,t) \ge 0 \text{ et } s + t = 1 \}\]
</p>

<p>
Une fonction \(\varphi : \setR^n \mapsto \setR)\) est dite convexe si pour tout \(u, v \in \setR^n\) et \((s,t) \in L\), on a :
</p>

<p>
\[\varphi(s \cdot u + t \cdot v) \le s \cdot \varphi(u) + t \cdot \varphi(v)\]
</p>
</div>
<div id="outline-container-org52f1303" class="outline-3">
<h3 id="org52f1303"><span class="section-number-3">6.1.</span> Formulation équivalente</h3>
<div class="outline-text-3" id="text-6-1">
<p>
En substituant \(s = 1 - t\), on obtient :
</p>

<p>
\[\varphi(u + t \cdot (v - u)) \le \varphi(u) + t \cdot (\varphi(v) - \varphi(u))\]
</p>

<p>
ou :
</p>

<p>
\[\varphi(u + t \cdot (v - u)) - \varphi(u) \le t \cdot (\varphi(v) - \varphi(u))\]
</p>
</div>
</div>
<div id="outline-container-orgb107de2" class="outline-3">
<h3 id="orgb107de2"><span class="section-number-3">6.2.</span> Différentielle</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Si \(\varphi\) est différentiable, on peut écrire par définition :
</p>

<p>
\[\differentielle{\varphi}{u}(t \cdot (v - u)) + \petito{t \cdot (v - u)} \le t \cdot (\varphi(v) - \varphi(u))\]
</p>

<p>
On peut bien entendu faire sortir le \(t\) par linéarité :
</p>

<p>
\[t \cdot \differentielle{\varphi}{u}(v - u) + \petito{t \cdot (v - u)} \le t \cdot (\varphi(v) - \varphi(u))\]
</p>

<p>
Il ne nous reste plus qu'à diviser par \(t\) et à faire tendre \(t \to 0\) pour annuler le terme d'erreur. On a alors la borne supérieure :
</p>

<p>
\[\differentielle{\varphi}{u}(v - u) \le \varphi(v) - \varphi(u)\]
</p>

<p>
En termes matriciels, cela se réécrit :
</p>

<p>
\[\partial \varphi(u) \cdot (v - u) \le \varphi(v) - \varphi(u)\]
</p>
</div>
</div>
<div id="outline-container-org9954d35" class="outline-3">
<h3 id="org9954d35"><span class="section-number-3">6.3.</span> Hessienne</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Supposons à présent que la fonction convexe \(\varphi : \setR^n \mapsto \setR\) soit deux fois continûment différentiable. Soit \(u,v \in \setR^n\). Posons \(\Delta = v - u\). On considère le développement d'ordre deux :
</p>

<p>
\[\varphi(v) = \varphi(u) + \partial \varphi(u) \cdot \Delta + \unsur{2} \cdot \Delta^\dual \cdot \partial^2 \varphi(u) \cdot \Delta + \petito{\Delta^2}\]
</p>

<p>
La borne supérieure de la différentielle nous dit que :
</p>

<p>
\[\partial \varphi(u) \cdot \Delta \le \varphi(v) - \varphi(u)\]
</p>

<p>
On a donc :
</p>

<p>
\[\unsur{2} \cdot \Delta^\dual \cdot \partial^2 \varphi(u) \cdot \Delta + \petito{\Delta^2} = \varphi(v) - \varphi(u) - \partial \varphi(u) \cdot \Delta \ge 0\]
</p>

<p>
c'est-à-dire :
</p>

<p>
\[\Delta^\dual \cdot \partial^2 \varphi(u) \cdot \Delta + \petito{\Delta^2} \ge 0\]
</p>

<p>
Choisissons \(\delta \in \setR^n\) et \(t \in \setR\). Considérons le cas où \(v = u + t \cdot \delta\). On a alors \(\Delta = t \cdot \delta\) et :
</p>

<p>
\[t^2 \cdot \delta^\dual \cdot \partial^2 \varphi(u) \cdot \delta + \petito{t^2 \cdot \delta^2} \ge 0\]
</p>

<p>
Il suffit alors de diviser par \(t^2\) et de faire tendre \(t \to 0\) pour obtenir :
</p>

<p>
\[\delta^\dual \cdot \partial^2 \varphi(u) \cdot \delta \ge 0\]
</p>

<p>
Comme ce doit être valable pour tout \(\delta \in \setR^n\), la Hessienne est définie positive en tout \(u \in \setR^n\).
</p>
</div>
</div>
<div id="outline-container-org979ba22" class="outline-3">
<h3 id="org979ba22"><span class="section-number-3">6.4.</span> Globalité</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Considérons le minimum global :
</p>

<p>
\[\lambda \in \arg\min_{x \in \setR^n} \varphi(x)\]
</p>

<p>
Supposons à présent que \(\varphi\) atteigne un minimum local en \(\gamma\). On sait que \(\varphi(\lambda) \le \varphi(\gamma)\) par définition de \(\lambda\). Mais comme \(\partial \varphi(\gamma) = 0\), on a aussi :
</p>

<p>
\[0 = \partial \varphi(\gamma) \cdot (\lambda - \gamma) \le \varphi(\lambda) - \varphi(\gamma)\]
</p>

<p>
On en déduit que :
</p>

<p>
\[\varphi(\gamma) \le \varphi(\lambda)\]
</p>

<p>
donc \(\varphi(\gamma) = \varphi(\lambda)\) est également un minimum global.
</p>

<p>
Attention toutefois, cela ne prouve aucunement que le point minimisant \(\varphi\) est unique.
</p>
</div>
</div>
<div id="outline-container-org75a25a1" class="outline-3">
<h3 id="org75a25a1"><span class="section-number-3">6.5.</span> Corollaire</h3>
<div class="outline-text-3" id="text-6-5">
<p>
Un corollaire important de ces résultats est que si \(\varphi\) est convexe et deux fois différentiable et que l'on trouve un point \(x\) tel que \(\partial \varphi(x) = 0\), ce point minimise localement \(\varphi\) car la Hessienne est définie positive. Le réel \(\varphi(x)\) est donc également le minimum global de \(\varphi\).
</p>
</div>
</div>
</div>
<div id="outline-container-org53fbc2d" class="outline-2">
<h2 id="org53fbc2d"><span class="section-number-2">7.</span> Convexité stricte</h2>
<div class="outline-text-2" id="text-7">
<p>
Une fonction \(\varphi : \setR^n \mapsto \setR)\) est dite strictement convexe si pour tout \(u, v \in \setR^n\) tels que \(u \ne v\) et tout \((s,t) \in L \setminus \{ (1,0),(0,1) \}\), on a :
</p>

<p>
\[\varphi(s \cdot u + t \cdot v) \strictinferieur s \cdot \varphi(u) + t \cdot \varphi(v)\]
</p>
</div>
<div id="outline-container-org31cd27f" class="outline-3">
<h3 id="org31cd27f"><span class="section-number-3">7.1.</span> Minima</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Supposons qu'il existe deux \(u,v \in \setR^n\) distincts (\(u \ne v\)) tels que \(\varphi(u) = \varphi(v)\) soit le minimum global de \(\varphi\). On a alors :
</p>

\begin{align}
\varphi(s \cdot u + t \cdot v) &\strictinferieur& s \cdot \varphi(u) + t \cdot \varphi(v) \)

\(
&\strictinferieur& (s + t) \cdot \varphi(u) = \varphi(u)
\end{align}

<p>
ce qui n'est pas possible puisque \(\varphi(u)\) est minimum global. Il existe donc au plus un seul \(u \in \setR^n\) minimisant globalement \(\varphi\) :
</p>

<p>
\[u = \arg\min_{x \in \setR^n} \varphi(x)\]
</p>
</div>
</div>
</div>
<div id="outline-container-org6d3acc7" class="outline-2">
<h2 id="org6d3acc7"><span class="section-number-2">8.</span> Concavité</h2>
<div class="outline-text-2" id="text-8">
<p>
Une fonction \(\psi : \setR^n \mapsto \setR\) est dite concave si pour tout \(u, v \in \setR^n\) et \((s,t) \in L\), on a :
</p>

<p>
\[\psi(s \cdot u + t \cdot v) \ge s \cdot \psi(u) + t \cdot \psi(v)\]
</p>

<p>
On voit que si \(\psi\) est concave, \(\varphi = -\psi\) est convexe. L'équivalence max-min nous montre alors que tout maximum local de \(\psi\) est également un maximum global.
</p>
</div>
</div>
<div id="outline-container-orgdc0b8eb" class="outline-2">
<h2 id="orgdc0b8eb"><span class="section-number-2">9.</span> Concavité stricte</h2>
<div class="outline-text-2" id="text-9">
<p>
Une fonction \(\psi : \setR^n \mapsto \setR\) est dite strictement concave si pour tout \(u, v \in \setR^n\) tels que \(u \ne v\) et tout \((s,t) \in L \setminus \{ (1,0),(0,1) \}\), on a :
</p>

<p>
\[\psi(s \cdot u + t \cdot v) \strictsuperieur s \cdot \psi(u) + t \cdot \psi(v)\]
</p>

<p>
On voit que si \(\psi\) est strictement concave, \(\varphi = -\psi\) est strictement convexe. L'équivalence max-min nous montre alors qu'il existe au plus un seul élément de \(\setR^n\) maximisant globalement \(\psi\).
</p>
</div>
</div>
<div id="outline-container-org6ab4468" class="outline-2">
<h2 id="org6ab4468"><span class="section-number-2">10.</span> Equation du second degré</h2>
<div class="outline-text-2" id="text-10">
<p>
Soit \(a,b,c \in \setR\) avec \(a \ne 0\). Soit le polynôme du second degré,
ou polynôme de degré \(2\) défini par :
</p>

<p>
\[p(x) = a \cdot x^2 + b \cdot x + c\]
</p>

<p>
pour tout \(x \in \setR\). Nous allons chercher un éventuel extrema
\(\gamma\) de ce polynôme. La dérivée première s'écrit :
</p>

<p>
\[\OD{p}{x}(x) = 2 \cdot a \cdot x + b\]
</p>

<p>
La condition :
</p>

<p>
\[\OD{p}{x}(\gamma) = 2 \cdot a \cdot \gamma + b = 0\]
</p>

<p>
nous donne :
</p>

<p>
\[\gamma = -\frac{b}{2a}\]
</p>

<p>
La dérivée seconde est donnée par :
</p>

<p>
\[\OOD{p}{x}(x) = 2 \cdot a\]
</p>

<p>
Si \(a \strictsuperieur 0\), la dérivée seconde est toujours positive et
\(\gamma\) minimise localement \(p\). On vérifie que \(p\) est strictement
convexe, et on en déduit que \(\gamma\) est l'unique réel qui minimise
globalement \(p\).
</p>

<p>
Par contre, si \(a \strictinferieur 0\), la dérivée seconde est toujours
négative et \(\gamma\) maximise localement \(p\). On vérifie que \(p\) est
strictement concave, et on en déduit que \(\gamma\) est l'unique réel
qui maximise globalement \(p\).
</p>
</div>
<div id="outline-container-org75f5d02" class="outline-3">
<h3 id="org75f5d02"><span class="section-number-3">10.1.</span> Racines</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Intéressons-nous à présent à l'écart par rapport à \(\gamma\) :
</p>

<p>
\[\delta = x - \gamma = x + \frac{b}{2 a}\]
</p>

<p>
On a donc :
</p>

<p>
\[x = \gamma + \delta = - \frac{b}{2a} + \delta\]
</p>

<p>
et :
</p>

<p>
\[x^2 = (\gamma + \delta)^2 = \delta^2 - \frac{\delta \cdot b}{a} + \frac{b^2}{4 \cdot a^2}\]
</p>

<p>
En injectant ces relations dans la définition du polynôme, on obtient :
</p>

\begin{align*}
p(\gamma + \delta) &=
a \cdot \delta^2 - b \cdot \delta + \frac{b^2}{4 \cdot a} + b \cdot \delta - \frac{b^2}{2 \cdot a} + c \\
&= a \cdot \delta^2 - \frac{b^2}{4 \cdot a} + c
\end{align*}

<p>
Cette expression nous permet d'obtenir les racines d'un polynôme du second degré. La condition :
</p>

<p>
\[p(\delta + \gamma) = 0\]
</p>

<p>
nous donne :
</p>

<p>
\[\delta^2 = \frac{b^2 - 4 \cdot a \cdot c}{4 \cdot a^2}\]
</p>

<p>
équation qui admet deux solution \(\delta_+, \delta_-\) :
</p>

<p>
\[ \delta_+ = \frac{\sqrt{ b^2 - 4 \cdot a \cdot c }}{2 \cdot a} \]
</p>

<p>
\[ \delta_- = - \frac{\sqrt{ b^2 - 4 \cdot a \cdot c }}{2 \cdot a} \]
</p>

<p>
Nous avons donc deux racines \(x_+,x_-\) :
</p>

<p>
\[ x_+ = \frac{-b + \sqrt{b^2 - 4 \cdot a \cdot c}}{2 \cdot a} \]
</p>

<p>
\[ x_- = \frac{-b - \sqrt{b^2 - 4 \cdot a \cdot c}}{2 \cdot a} \]
</p>

<p>
telles que \(p(x_+) = p(x_-) = 0\).
</p>
</div>
</div>
</div>
<div id="outline-container-org8e4442a" class="outline-2">
<h2 id="org8e4442a"><span class="section-number-2">11.</span> Moindres-carrés</h2>
<div class="outline-text-2" id="text-11">
<p>
Soit la matrice \(A \in \matrice(\setR,m,n)\) et le vecteur colonne
\(b \in \matrice(\setR,m,1)\). On aimerait trouver le \(\xi \in
\matrice(\setR^n,n,1)\) qui minimise la norme de l'erreur \(e\) définie
par :
</p>

<p>
\[e(x) = A \cdot x - b\]
</p>

<p>
pour tout \(x \in \matrice(\setR^n,n,1)\). Comme la fonction \(\norme{x}
\mapsto \norme{x}^2\) est strictement croissante sur \(\norme{x} \in
\setR^+\), cela revient à minimiser :
</p>

<p>
\[\mathcal{E}(x) = \norme{x}^2 = e(x)^\dual \cdot e(x) = (A \cdot x - b)^\dual \cdot (A \cdot x - b)\]
</p>

<p>
En développant, on obtient :
</p>

<p>
\[\mathcal{E}(x)
= x^\dual \cdot A^\dual \cdot A \cdot x - x^\dual \cdot A^\dual \cdot b - b^\dual \cdot A \cdot x + b^\dual \cdot b\]
</p>

<p>
Comme \((A^\dual \cdot A)^\dual = A^\dual \cdot A\) et \(x^\dual \cdot
A^\dual \cdot b = b^\dual \cdot A^\dual \cdot x\), l'annulation de la
dérivée nous donne :
</p>

<p>
\[\partial \mathcal{E}(\xi) = 2 A^\dual \cdot A \cdot \xi - 2 A^\dual \cdot b = 0\]
</p>

<p>
d'où l'on tire directement :
</p>

<p>
\[A^\dual \cdot A \cdot \xi = A^\dual \cdot b\]
</p>

<p>
Si \(A^\dual \cdot A\) est inversible, on en déduit que :
</p>

<p>
\[\xi = \left(A^\dual \cdot A\right)^{-1} \cdot A^\dual \cdot b\]
</p>
</div>
<div id="outline-container-orga1b8478" class="outline-3">
<h3 id="orga1b8478"><span class="section-number-3">11.1.</span> Orthogonalité</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Considérons la partition en colonne \(A = [c_1 \ ... \ c_n]\). On a alors :
</p>

<div class="org-center">
<p>
\(
A^\dual =
</p>
\begin{Matrix}{c}
c_1^\dual \\ \vdots \\ c_n^\dual
\end{Matrix}
<p>
\)
</p>
</div>

<p>
La propriété :
</p>

<p>
\[A^\dual \cdot (A \cdot \xi - b) = A^\dual \cdot A \cdot \xi - A^\dual \cdot b = 0\]
</p>

<p>
nous dit donc que les colonnes de \(A\) sont orthogonales au vecteur \(r = A \cdot \xi - b\) :
</p>

<p>
\[\scalaire{c_i}{r} = c_i^\dual \cdot r = \ligne_i [ A^\dual \cdot (A \cdot \xi - b) ] = 0\]
</p>
</div>
</div>
<div id="outline-container-orgfc1ac72" class="outline-3">
<h3 id="orgfc1ac72"><span class="section-number-3">11.2.</span> Approximation de fonctions</h3>
<div class="outline-text-3" id="text-11-2">
<p>
On désire obtenir une approximation \(w\) d'une fonction \(u\) dont on connaît les valeurs aux points \(x_1,...,x_m\) en minimisant l'erreur :
</p>

<p>
\[\sum_{i=1}^{m} ( u(x_i) - w(x_i) )^2\]
</p>

<p>
On choisit alors les fonctions \(\varphi_1(x),...,\varphi_n(x)\), où \(n \le m\) et on pose :
</p>

<p>
\[w(x) = \sum_{i=1}^m a_i \cdot \varphi_i(x)\]
</p>

<p>
En utilisant les matrices :
</p>

\begin{align}
A &= [\varphi_j(x_i)]_{i,j} \)

\(
a &= [a_1 \ a_2 \ ... \ a_m]^T \)

\(
b &= [u(x_1) \ u(x_2) \ ... \ u(x_n)]^T
\end{align}

<p>
on peut réécrire le problème de minimisation comme suit :
</p>

<p>
\[a = \arg\min_z (A \cdot z - b)^\dual \cdot (A \cdot z - b)\]
</p>

<p>
La solution est donc :
</p>

<p>
\[a = (A^\dual \cdot A)^{-1} \cdot A^\dual \cdot b\]
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Auteur: chimay</p>
<p class="date">Created: 2025-12-30 mar 16:38</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
